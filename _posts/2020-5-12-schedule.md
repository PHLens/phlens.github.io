---
title: "OS-处理机调度"
date: 2020-05-12 12:00+0000
category: OS
---

### CPU资源的时分复用

---

***进程切换***

> CPU资源当前占用者的切换

+ 保存当前进程在PCB中的执行上下文（CPU状态）
+ 恢复下一个进程的执行上下文



***处理机调度***

+ 从***就绪队列***中挑选下一个占用CPu运行的进程
+ 从***多个可用CPU***中挑选就绪进程可以使用的CPU资源



***调度程序***

+ 挑选就绪进程的***内核函数***
+ 考虑调度的策略（调度原则）
+ 调度的时机：何时进行调度？
    + 进程从运行状态切换到等待状态
    + 进程被终结
    + 当前进程主动放弃CPU时
    + 中断请求被服务例程响应完成时
    + 进程的时间片用完
    + 高优先级进程从等待切换到就绪



### 衡量调度算法的准则

---

> 一些概念
>
> + CPU使用率：CPU处于忙状态的时间百分比
> + 吞吐量：单位时间内完成的进程数量
> + 周转时间：进程从初始化到结束（***包括等待***）的总时间
> + 等待时间：进程在就绪队列中的总时间
> + 响应时间：从提交请求到产生响应所花费的总时间

***响应时间目标***

+ 减少响应时间：及时处理用户的输入请求，尽快将输出反馈
+ 减少平均响应时间的波动
    + 在交互系统中，可预测性比高差异低平均更重要
+ 响应时间是操作系统的***计算延迟***



***吞吐量目标***

+ 增加吞吐量
    + 减少开销（上下文切换）
    + 系统资源的高效利用（CPU、I/O设备）
+ 减少等待时间
+ 保证吞吐量不受用户交互的影响（必须不时进行调度，不论是否存在交互任务）
+ 吞吐量是操作系统的***计算带宽***



***公平性目标***

+ 保证每个进程占用相同的CPU时间（是否公平？用户进程多怎么办？）
+ 保证每个进程的等待时间相同
+ 公平通常会增加平均响应时间



### 调度算法

---

#### 先来先服务算法（FCFS）

+ 依据进程进入就绪状态的先后顺序排列
+ 进程进入等待或结束状态时，，就绪队列中的下一个进程占用CPU
+ 优点：实现简单
+ 缺点：
    + 平均等待时间波动较大，短进程可能排在长进程后面
    + I/O资源和CPU资源的利用率较低
        + I/O操作密集的进程可能一直等待，导致I/O资源利用率低
        + I/O操作的进程也可能一直排在CPU密集型进程前面，导致CPU一直得不到使用



#### 短进程优先算法（SPN）

+ 选择就绪队列中执行时间最短进程占用CPU进入运行状态

+ 就绪队列按***预期***的执行时间来排序

+ 短剩余时间优先算法（SRT）

    + SPN的可抢占改进，即若运行中的进程遇到一个新的进程比当前进程的剩余运行时间还要短，则直接抢占CPU资源

+ SPN具有***最优的平均周转时间***

+ 缺点：

    + 可能导致饥饿现象：连续的短进程流使得长进程无法获得CPU资源

    + ***需要预知未来***

        + 如何预估进程执行时间？

        + 询问用户：超过用户设定时间直接杀死

        + 利用历史的执行时间来预估

            $\tau_{n+1} =\alpha t_n+ (1-\alpha) \tau_n$

            + $t_n$第n次CPU计算时间
            + $\tau_{n+1}$第n+1次的CPU计算时间预估



#### 最高响应比优先算法（HRRN）

+ 选择就绪队列中响应比R值最高的进程

    $R = (w+s)/s$

    w:等待时间

    s：执行时间

+ 在短进程优先算法的基础上改进

+ 不可抢占

+ 关注了进程的等待时间，防止无期限的推迟



#### 时间片轮转算法（RR，Round-Robin）

+ 时间片：分配处理机资源的基本时间单元
+ 算法思路：
    + 时间片结束时，按FCFS算法切换到下一个就绪进程
    + 每隔(n-1)个时间片进程执行一个时间片q
+ RR算法开销：主要是额外的上下文切换
+ 时间片的合理设置
    + 时间片太大
        + 等待时间过长
        + 极限情况下退化成FCFS
    + 时间片太小
        + 反应迅速，产生大量上下文切换
        + 影响系统吞吐量
    + 经验规则：维持上下文切换开销处于1%以内



#### 多级队列调度算法（MQ）

+ 就绪队列分成多个独立的子队列（如前台和后台）
+ 每个队列有自己的调度策略（如前台RR，后台FCFS）
+ 队列之间的调度
    + 固定优先级
        + 先处理前台，再处理后台
        + 可能导致饥饿
    + 时间片轮转：每个队列都得到一个确定的能够调度其进程的CPU总时间
        + 如：80%CPU时间用于前台，20%用于后台

***多级反馈队列算法（MLFQ）***

+ 进程可在不同队列间移动的多级队列算法
    + 时间片大小随着优先级级别（级别数低的是高优先级）的增加而增加
    + 如果进程在当前的时间片没有用完则降到下一优先级
+ 特点：
    + CPU密集型的进程优先级下降的很快
    + I/O密集型的进程停留在高优先级



#### 公平共享调度（FSS）

+ FSS控制用户对系统资源的访问
+ 一些用户组比其他用户组更重要
+ 保证不重要的组无法垄断资源
+ 未使用的资源按比例分配
+ 没有达到资源使用率目标的组获得更高的优先级



### 传统调度算法总结

---

+ FCFS：不公平，平均等待时间差
+ SPN：
    + 不公平，但平均周转时间最小
    + 需要精确预测计算时间
    + 可能导致饥饿
+ HRRN：基于SPN，不可抢占
+ RR：公平，但是平均等待时间较长
+ MLFQ：多种算法的集成
+ 公平共享调度：保证公平



### 实时操作系统和多处理机调度

---

#### 实时操作系统

+ 正确性依赖于其时间和功能两方面的操作系统
+ 性能指标：
    + 时间约束的及时性
    + 速度和平均性能相对不重要
+ 特性：时间约束的可预测性

+ 强实时操作系统
    + 要求在指定时间内必须完成重要的任务
+ 弱实时操作系统
    + 重要进程有高优先级，要求尽量但非必须完成

***实时任务***

+ 任务（工作单元）
    + 一次计算，一次文件读取，一次信息传递等等
+ 任务属性
    + 完成任务所需要的资源
    + 定时参数
+ 周期实时任务：一系列相似的任务
    + 任务有规律地重复
    + 周期p=任务请求时间间隔（p>0）
    + 执行时间e=最大执行时间（0<e<p）
    + 使用率U=e/p

***软时限和硬时限***

+ 硬时限
    + 错过任务时限会导致灾难性或非常严重的后果
    + 必须验证，在最坏的情况下能够满足时限
+ 软时限
    + 通常能满足任务时限，如不能则降低要求
    + 尽力保证满足任务时限

***实时调度算法***

+ 速率单调调度算法（RM）
    + 通过周期安排优先级
    + 周期越短优先级越高
    + 执行周期最短的任务
+ 最早截止时间优先算法（EDF）
    + 截止时间越早优先级越高
    + 执行截止时间最早的任务



#### 多处理器调度

+ 多个处理机组成一个多处理机系统
+ 处理机间可负载共享



***对称多处理器调度（SMP）***

+ 每个处理器运行自己的调度程序
+ 调度程序对共享资源的访问需要同步
+ 进程分配
    + 静态进程分配
        + 进程从开始到结束都被分配到一个固定的处理机上运行
        + 每个处理机有自己的就绪队列
        + 调度开销小
        + 各处理机可能忙闲不均
    + 动态进程分配
        + 进程在执行中可分配到任意的空闲处理机执行
        + 所有处理机共享一个公共的就绪队列
        + 调度开销大
        + 各处理机的负载时均衡的



### 优先级反置

---

> 操作系统中出现高优先级的进程长时间等待低优先级进程所占用资源的现象。
>
> **任何基于优先级的可抢占的调度算法都存在优先级反置**

解决方法：

+ 优先级继承
    + 占用资源的优先级进程继承申请资源的高优先级进程的优先级
    + 只在占有资源的低优先级进程被阻塞时，才提高其优先级
+ 优先级天花板协议
    + 占用资源进程的优先级和所有可能的申请该资源的进程的最高优先级相同
    + 不管是否发生等待，都提升占用资源的进程的优先级
    + 但这样可能导致所有进程优先级不断提高，最终达到最高优先级就失去了意义

