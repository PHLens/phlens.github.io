---
title: "OS-页面置换算法（1）"
category: OS
date: 2020-05-10 17:50+0000
---

### 页面置换算法的功能和目标

---

#### 功能

+ 当出现缺页异常，需要调入新的页面而内存已满时，置换算法***选择被置换的物理页面***

#### 目标

+ 尽可能***减少页面的调入调出次数***
+ 选择未来不再访问或短期内不再访问的页面进行调出

同时要考虑一些不该调出的页面，即***页面锁定***：

+ 描述必须常驻内存的逻辑页面
+ 操作系统的关键部分
+ 要求相应速度和代码和数据
+ 页表项中的锁定标志位（lock bit）



### 置换算法的评价方法

---

1. 模拟页面置换行为，记录产生缺页的次数
2. 更少的缺页，意味着更好的性能



### 页面置换算法的分类

---

1. 局部的页面置换算法

    > 置换页面的选择范围仅限于***当前进程占用***的物理页面内

    + 最优算法、先进先出算法（FIFO）、最近最久未使用算法（LRU）
    + 时钟算法（Clock）、最不常用算法

2. 全局页面置换算法

    > 置换页面的选择范围时***所有可换出***的物理页面

    + 工作集算法
    + 缺页率算法



### 局部页面置换算法



#### 最优页面置换算法（OPT，optimal）

---

+ 基本思路：计算在未来最长时间不妨问的页面
+ 算法实现：
    + 缺页时，计算每一个逻辑页面的下一次访问时间
    + 选择未来最长时间不访问的页面
+ 算法特征：
    + 缺页最少，是理想情况
    + 实际系统中***无法实现***
    + 无法预知每个页面在下次访问前的等待时间
    + 可作为置换算法的性能评价依据
        + 现在模拟器上运行某个程序，记录每一次的页面访问情况
        + 第二遍运行时使用最优算法



#### 先进先出算法（FIFO）

---

+ 基本思路：选择***在内存驻留时间最长***的页面进行置换
+ 算法实现：
    + 维护一个记录所有位于内存中的逻辑页面链表
    + 链表元素按***驻留内存的时间排序***。链首最长，链尾最短
    + 出现缺页时，选择链首页面进行替换，新页面加到链尾
+ 特征：
    + 实现简单
    + 性能较差，调出的页面可能是经常访问的
    + 进程分配的物理页面数量增加时，缺页并不一定减少（Belady现象）
    + 基本不单独使用



#### 最近最久未使用算法（LRU，Least Recently Used）

---

+ 基本思路：
    + 选择***最长时间没有被引用***的页面进行置换
    + 由局部性原理
+ 算法实现：
    + 缺页时，计算内存中每个逻辑页面的上一次访问时间
    + 选择上一次使用到当前时间最长的页面
+ 特征：是最优置换算法的一种近似，通过对过去的分析来达到预测未来的目的。

可能的实现方法：

1. 页面链表
    + 系统维护一个按最近一次访问时间排序的页面链表
        + 链表首节点是最近刚刚使用过的页面
        + 链表尾节点是最久尾使用的页面
    + 访问内存时，找到相应的页面，并移至链表之首
    + 缺页时，置换链表尾节点的页面
2. 活动页面栈
    + 访问页面时，将此页号压入栈顶，并将栈内相同的页号抽出
    + 缺页时，置换栈底的页面

> 但不论是哪种实现方法，开销都比较大



#### 时钟置换算法（Clock）

---

+ 基本思路：仅对页面的访问情况进行***大致***的统计
+ 数据结构：
    + 在页表项中增加***访问位***，描述页面在过去一段时间内的访问情况
    + 各页面组织成***环形链表***
    + 指针指向最先调入的页面
+ 算法：
    + 访问页面时，在页表项记录页面的访问情况
    + 缺页时，从指针开始顺序查找未被访问的页面进行替换
+ 特征
    + 时钟算法时LRU和FIFO的折衷

具体实现：

+ 页面装入内存时，访问位初始化为0
+ 访问页面（读/写）时，访问为置1
+ 缺页时，从指针当前位置顺序检查环形链表
    + 访问位为0，则置换该页面
    + 访问位为1，则置访问位为0，并移动到下一个页面，知道找到可置换的页面

对于已修改的页面，每次直接置换导致开销会很大，可以采用一些延迟置换策略，如下面的改进的Clock算法。



##### 改进的Clock算法

+ 思路：减少修改页的缺页处理开销
+ 算法：
    + 在页表项中增加修改位，并在访问时进行相应的修改
    + 缺页时，修改页面标志位，以跳过有修改的页面
        + 具体来说，一个页面用两个位来标志访问和修改
        + 遇到00直接替换
        + 遇到01改成00，遇到10改成00，遇到11改成01



#### 最不常用算法（LFU，Least Frequently Used）

---

+ 思路： 缺页时，置换访问次数最少的页面
+ 实现：
    + 每个页面设置以恶搞访问计数
    + 每次访问页面时，访问计数加1
    + 缺页时，选择访问计数最小的页面进行替换
+ 特征：
    + 开销大
    + 开始时频繁使用，但以后不使用的页面很难置换
        + 解决方法：计数定期右移
+ 与LRU算法的区别
    + LRU关注页面***多久未访问***，时间越短越好
    + LFU关注页面***访问次数***，次数越多越好



#### Belady现象

---

> 采用FIFO等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象

+ 原因
    + FIFO算法的置换特征与进程访问内存的动态特征矛盾
    + 被他置换出去的页面并不一定是进程近期不会访问的
+ LRU算法由于是对过去**所有页面**的访问顺序都有记录，因此他替换的页面一定是进程近期不会访问的，因此就**不存在Belady现象**



#### LRU、FIFO和Clock的比较

---

+ LRU和FIFO本质上来说都是先进先出的思想
    + LRU依据页面的最近访问时间排序，FIFO则依据页面进入内存的时间排序
    + LRU需要动态的调整顺序，而FIFO的页面进入时间是固定不变的
    + 在***页面进入内存后不被访问***的情况下，LRU算法也就退化成了FIFO算法
+ LRU算法虽然性能好，但是系统开销大，需要实时维护页面顺序
+ FIFO虽然开销小，但是会出现Belady现象
+ Clock算法是二者的折衷
    + 页面访问时，不动态调整页面在链表中的顺序，仅做标记
    + 缺页时，再通过扫描更改标志位间接地调整顺序，这种调整完全由硬件完成，因此速度很快
+ 对于未被访问的页面，Clock算法和LRU算法表现一样好
+ 对于被访问的页面，Clock算法不能记录准确的访问顺序，而LRU算法可以

